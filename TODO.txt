1. consider moving maxQuantity to model
2. Mimic tile classes for entities
2.5. rename commondata to shareddata
3. Do optimisation for stateless tiles ONLY when necessary. Would involve a lot of work for little gain
3??? Optimisation for stateless Tiles. Would not be copied during cloning (tile's clone method STILL clones, user would have to handle it manually). The only instance would be in resource manager.
3.1??? Optimisation for stateless components. Similar, but Tiles would have to handle it. Only instances would be in component registrars. Would require tiles to use raw pointers and manage components manually.
3.2 USE DynamicPtr from LibS - factory would return an owning or nonowning pointer depending on statefullness

5. Decouple WindowSpaceManager with sf::Window (As done in carcassone). Make it automatic instead of unique_ptr
7. Clear world generation code
9. in entity manager pass world by reference
11. Do proper logging.
12. Clean some files - make more classes (for example scanForFiles from Root should not be there)
13. Clean member ordering and use automatic objects wherever possible.
14. Rework usage of events
15. Pass RenderStates by CONST reference
16. Make renderers less dependent on WindowSpaceManager. Pass parent views to draw methods if relevant.
17. Make a system that handles moving items between world and inventory (inv->inv, inv->world, world->inv, world->world).
18. Look around for names that can be made more meaningful because the project evolved and some names should mean different things than earlier
19. Make camera like the one in Carcassone. Move there everything involving camera (for example conversion between coordinates)
20. Direction class similar to one in Carcassone


21. WINDOW SYSTEM
    - WindowSpaceManager allows for dynamic creation (registration) of regions and scenes (by subdividing vertically or horizontally (like a tree)), classes that are part of the background regions derive from a special class that makes it possible to callback sfml events
    - Every window derives from an abstract class, a lot of parametrization
    - popup window and inventory window is the same class with different values
    - window content (interior) is injected into a window class (make it very generic)
    - window content is the final handler of sfml events
    - sfml events are distributed from game loop to WindowSpaceManager to regions/windows
    - WindowSpace or something, 1. main window space in WindowSpaceManager for popup windows, 2. other windowSpace for user ui panel, both with different constraints on windows
    - on mouse down remembers where it was send so the next mouse up will be send there too

22. Simplified sprite system
    - AnimatedSprite class that holds instances of Sprite (x, y, width, height, later also spritesheet id if needed) and table of frame time sums (for binary search)
    - returns a sprite when given time
    - all sprites in game are to be represented with this class

23. Convert from pixel units to tile units. (1 tile is 32 pixels)