

0.9. consider passing tilestack to the render function
0.99. consider making a sprite selector class that can be dynamically specified during creation of tiles.
    - it would handle sprite selection based on desired tile aspects or some other source (quantity based, weighted)
    - think of a way to make it performant and VERY generic
1. consider moving maxQuantity to model
2. Mimic tile classes for entities
2.4. Try to do MVC class and inherit from it in tiles and entities, everything related to mvc
2.5. rename commondata to shareddata

3. Do prefabs for entities too and use Component for entities

5. Decouple WindowSpaceManager with sf::Window (As done in carcassone). Make it automatic instead of unique_ptr
7. Clear world generation code
9. in entity manager pass world by reference
11. Do proper logging.
12. Clean some files - make more classes (for example scanForFiles from Root should not be there)
13. Clean member ordering and use automatic objects wherever possible.
14. Rework usage of events
15. Pass RenderStates by CONST reference
16. Make renderers less dependent on WindowSpaceManager. Pass parent views to draw methods if relevant.
17. Make a system that handles moving items between world and inventory (inv->inv, inv->world, world->inv, world->world).
17.5. Recode inventory system
18. Look around for names that can be made more meaningful because the project evolved and some names should mean different things than earlier
19. Make camera like the one in Carcassone. Move there everything involving camera (for example conversion between coordinates)
20. Direction class similar to one in Carcassone


21. WINDOW SYSTEM AND DIVISION BASED WINDOW SPACE MANAGEMENT
    - WindowSpaceManager allows for dynamic creation (registration) of regions and scenes (by subdividing vertically or horizontally (like a tree)), classes that are part of the background regions derive from
     a special class that makes it possible to callback sfml events
        priority: by pixels -> by percentage -> "what's left"
    - Every window derives from an abstract class, a lot of parametrization
    - popup window and inventory window is the same class with different values
    - window content (interior) is injected into a window class (make it very generic)
    - window content is the final handler of sfml events
    - sfml events are distributed from game loop to WindowSpaceManager to regions/windows
    - WindowSpace or something, 1. main window space in WindowSpaceManager for popup windows, 2. other windowSpace for user ui panel, both with different constraints on windows
    - on mouse down remembers where it was send so the next mouse up will be send there too
    - also always sends to region under mouse
    - event callbacks receive references to regions

22. Simplified sprite system
    - AnimatedSprite class that holds instances of Sprite (x, y, width, height, later also spritesheet id if needed) and table of frame time sums (for binary search)
    - returns a sprite when given time
    - all sprites in game are to be represented with this class

23. Convert from pixel units to tile units. (1 tile is 32 pixels)


later it could be expanded to produce lightmap fast with the described method and then second pass for player's line of sight using raycasting